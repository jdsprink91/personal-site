---
import BaseLayout from "../layouts/BaseLayout.astro";

// note the empty p tags below the inputs and textarea
// I'm doing this so that the scoped styles can pick up
// what needs to be styled. I'm just going to use
// javascript to toggle the display
---

<style>
  form > * + * {
    margin-top: 1rem;
  }

  label {
    display: block;
  }

  label + * {
    margin-top: 0.5rem;
  }

  input,
  textarea {
    width: 100%;
  }

  textarea {
    height: 5rem;
    max-width: 100%;
  }

  input + p,
  textarea + p {
    margin-top: 0.5rem;
    font-size: 0.75rem;
    color: red;
    display: none;
  }

  @media screen and (max-width: 30rem) {
    button {
      width: 100%;
      justify-content: center;
    }
  }
</style>

<BaseLayout pageTitle="Contact" headingCopy="Contact">
  <form
    name="contact"
    method="post"
    data-netlify="true"
    action="/success"
    novalidate="true"
  >
    <div>
      <label for="name">Your Name:</label>
      <input
        id="name"
        type="text"
        name="name"
        placeholder="Name"
        required
        data-validation-msg="Tell me your name!"
      />
      <p></p>
    </div>
    <div>
      <label for="email">Your Email:</label>
      <input
        id="email"
        type="email"
        name="email"
        placeholder="Email"
        required
        data-validation-msg="HEY! What's your email?? Put in one that is ~~valid~~."
      />
      <p></p>
    </div>
    <div>
      <label for="message">Your Message:</label>
      <textarea
        name="message"
        id="message"
        placeholder="Write me a message"
        required
        data-validation-msg="You're not gonna write me anything?"></textarea>
      <p></p>
    </div>
    <button type="submit">Submit</button>
  </form>
</BaseLayout>

<script>
  // some page state
  let hasTriedFormSubmission = false;

  // functions used for displaying and hiding the form errors
  const inputElms = document.querySelectorAll<
    HTMLInputElement | HTMLTextAreaElement
  >("input,textarea");

  const showErrorIfNeedBe = (elm: HTMLInputElement | HTMLTextAreaElement) => {
    if (!elm.validity.valid && !elm.classList.contains("invalid")) {
      elm.classList.add("invalid");

      const p = elm.nextSibling as HTMLParagraphElement;
      p.style.display = "block";
      p.innerText = elm.dataset.validationMsg ?? "";
    }
  };

  const removeErrorIfNeedBe = (elm: HTMLInputElement | HTMLTextAreaElement) => {
    if (elm.validity.valid && elm.classList.contains("invalid")) {
      elm.classList.remove("invalid");
      if (elm.nextSibling) {
        const p = elm.nextSibling as HTMLParagraphElement;
        p.style.display = "none";
        p.innerText = "";
      }
    }
  };

  // set up the event listeners
  document
    .querySelector<HTMLFormElement>("form")
    ?.addEventListener("submit", (event) => {
      if (
        !event.currentTarget ||
        !(event.currentTarget instanceof HTMLFormElement) ||
        !event.currentTarget.checkValidity()
      ) {
        // show the errors if need be, then prevent the form from submitting
        inputElms.forEach((node) => {
          showErrorIfNeedBe(node);
        });
        event.preventDefault();
        hasTriedFormSubmission = true;
        return;
      }
    });

  // what would be the best UX here?
  // I could just simplify the error message
  // and say something like "email is required and enter a valid email address and call it good"
  inputElms.forEach((node) => {
    node.addEventListener("input", (event) => {
      if (
        event.target instanceof HTMLInputElement ||
        event.target instanceof HTMLTextAreaElement
      ) {
        if (hasTriedFormSubmission) {
          removeErrorIfNeedBe(event.target);
        }
      }
    });
  });
</script>
