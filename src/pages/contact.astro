---
import BaseLayout from "../layouts/BaseLayout.astro";

// note the empty p tags below the inputs and textarea
// I'm doing this so that the scoped styles can pick up
// what needs to be styled. I'm just going to use
// javascript to toggle the display
---

<style>
  form > * + * {
    margin-top: 1rem;
  }

  label {
    display: block;
  }

  label + * {
    margin-top: 0.5rem;
  }

  input,
  textarea {
    width: 100%;
  }

  textarea {
    height: 5rem;
    max-width: 100%;
  }

  input + p,
  textarea + p {
    margin-top: 0.5rem;
    font-size: 0.75rem;
    color: red;
    display: none;
  }

  @media screen and (max-width: 30rem) {
    button {
      width: 100%;
      justify-content: center;
    }
  }
</style>

<BaseLayout pageTitle="Contact" headingCopy="Contact">
  <form
    name="contact"
    method="post"
    data-netlify="true"
    action="/success"
    novalidate="true"
  >
    <div>
      <label for="name">Your Name:</label>
      <input
        id="name"
        type="text"
        name="name"
        placeholder="Name"
        required
        data-value-missing-msg="Tell me your name!"
      />
      <p></p>
    </div>
    <div>
      <label for="email">Your Email:</label>
      <input
        id="email"
        type="email"
        name="email"
        placeholder="Email"
        required
        data-value-missing-msg="HEY! What's your email??"
        data-type-missing-msg="That doesn't look like an email to me."
      />
      <p></p>
    </div>
    <div>
      <label for="message">Your Message:</label>
      <textarea
        name="message"
        id="message"
        placeholder="Write me a message"
        required
        data-value-missing-msg="You're not gonna write me anything?"></textarea>
      <p></p>
    </div>
    <button type="submit">Submit</button>
  </form>
</BaseLayout>

<script>
  const inputElms = document.querySelectorAll<
    HTMLInputElement | HTMLTextAreaElement
  >("input,textarea");

  const showErrorIfNeedBe = (elm: HTMLInputElement | HTMLTextAreaElement) => {
    if (!elm.validity.valid && !elm.classList.contains("invalid")) {
      elm.classList.add("invalid");

      const p = elm.nextSibling as HTMLParagraphElement;
      p.style.display = "block";

      if (elm.validity.valueMissing) {
        p.innerText = elm.dataset.valueMissingMsg ?? "";
      }

      if (elm.validity.typeMismatch) {
        const p = document.createElement("p");
        p.innerText = elm.dataset.typeMissingMsg ?? "";
      }
    }
  };

  const removeErrorIfNeedBe = (elm: HTMLInputElement | HTMLTextAreaElement) => {
    if (elm.validity.valid && elm.classList.contains("invalid")) {
      elm.classList.remove("invalid");
      if (elm.nextSibling) {
        const p = elm.nextSibling as HTMLParagraphElement;
        p.style.display = "none";
        p.innerText = "";
      }
    }
  };

  // oo this is going to be interesting
  // I like this less noisy form, but now the strategy
  // is going to have to change
  // 1. will need to store that the form is dirty, meaning
  // we tried to submit it once and it needs validation
  // 2. If it is dirty, then I want to do two things:
  // ... I think. Will need to think about this more
  document
    .querySelector<HTMLFormElement>("form")
    ?.addEventListener("submit", (event) => {
      if (
        !event.currentTarget ||
        !(event.currentTarget instanceof HTMLFormElement) ||
        !event.currentTarget.checkValidity()
      ) {
        // show the errors if need be, then prevent the form from submitting
        inputElms.forEach((node) => {
          showErrorIfNeedBe(node);
        });
        event.preventDefault();
        return;
      }
    });

  inputElms.forEach((node) => {
    node.addEventListener("input", (event) => {
      if (
        event.target instanceof HTMLInputElement ||
        event.target instanceof HTMLTextAreaElement
      ) {
        removeErrorIfNeedBe(event.target);
      }
    });
  });
</script>
